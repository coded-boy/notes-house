## 一、常见的实现方式

1. 哈希表

   哈希表是一种以键值对（key-value）存储数据的结构，输入 key 之后，能够以 O(1) 的时间复杂度找到对应的value。出现哈希冲突的时候就会拉出一个链表。

   优缺点：适用于等值查询的场景，但因为数据不是有序组织的，所以对于范围查询就必须做全表扫描。

   // todo 图 45讲

2. 有序数组

   有序数组会根据数据的大小按顺序将数据存放在数组中。

   优缺点：可以使用二分法以 O(logN) 的时间复杂度找到对应的数据，对于范围查询也支持。但是数据更新的成本很高，每次插入或删除都可能移动很多条记录，所以对于这种结构的索引，查询效率高，插入删除效率低，适用于储静态的数据。
   // todo 图 45讲

3. 查找树

   平衡二叉查找树的特点就是：每个节点的左孩子小于父节点，父节点小于右孩子。左子树与右子树高度之差的绝对值不超过1。查询的时间复杂度是 O(logN)，更新的时间复杂度也是 O(logN)。

   B-树：多路平衡查找树。每个节点最多包含 k 个孩子，k被称为 B树 的阶。一棵 m 阶 B树

   * 根节点至少有两个孩子
   * 每个中间节点都包含 k-1 个元素和 k 个孩子，其中 m/2 <= k <= m
   * 每个叶子节点都包含 k-1 个元素，其中 m/2 <= k <= m
   * 所有叶子节点都位于同一层
   * 每个节点中的元素从小到大排列，节点当中 k-1 个元素正好是 k 个孩子包含的元素的值域分划。

   ![image-20210808135724507](images/image-20210808135724507.png)

   B+树：B树的变体。

   * 有 k 个孩子的中间节点包含有 k 个元素（B树中是 k-1 个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。
   * 所有的叶子结点中包含了全部元素的信息，且叶子结点根据关键字的大小从小到大顺序链接成双向链表。
   * 所有的中间节点元素都同时存在于子节点。

   ![image-20210808140604369](images/image-20210808140604369.png)

   B+树的优点：

   * 查询的 IO 次数更少：中间节点不存储完整数据，只做索引，所以相同大小的数据页可以容纳更多的节点元素
   * 查询性能稳定：每次查询都必须找到叶子节点，而 B树最好的情况是只查根节点，最坏的情况是查到叶子节点，所以 B+树的每一次查找都是稳定的。
   * 范围查询简便：数据存放在叶子节点，并且所有节点组成大小有序的链表，所以找到第一个满足条件的节点后，直接在链表上做遍历即可。

## 二、InnoDB的索引实现方式

​		InnoDB 使用了 B+树作为索引底层实现的数据结构，每一个索引在 InnoDB 里面对应一棵 B+树。表中的数据根据主键大小顺序存放在主键索引的叶子节点中，这种索引方式的表称为索引组织表。

​		**上期内容回顾总结：**各个数据页可以组成一个双向链表，每个数据页中的记录会按照主键值从大到小的顺序组成一个单向链表，每个数据页都会为存储在它里面的记录生成一个页目录，在通过主键查找某条记录的时候，就可以在页目录中使用二分法找到对应的槽（数据页中的记录每 1-8 条，或者 4-8 条划分为一组，组内最大的记录的地址偏移量称为一个槽），然后再遍历该槽对应的分组就可以找到指定的记录。

![image-20210808151500451](images/image-20210808151500451.png)

## 三、主键索引和非主键索引

1. 主键索引（聚簇索引）

   主键索引的叶子节点存储的是整条记录的数据。

2. 非主键索引（二级索引）

   非主键索引的叶子节点存储的内容是记录对应的主键值。

3. 基于主键索引和普通索引的查询有什么区别？

   ```SQL
   create table T (
   	id int primary key,
       id_card varchar(20) not null,
       name varchar(50) not null,
       address varchar(128),
       KEY `idx_id_card` (id_card)
   )
   ```

   如果查询语句是 select * from T where id = 500，即主键查询方式，则只需要搜索 主键索引这棵B+ 树；

   如果查询语句是 select name from T where id_card = 'xxxx'，即走普通索引查询方式，则需要先搜索 id_card 索引树，得到 id 的值，再通过这个 id 去主键索引树搜索一次。回到主键索引搜索的过程称为回表。

## 四、覆盖索引

​		执行 select name from T where id_card = 'xxxx' 这条语句需要回表查询。如果这个查询操作很高频，那就可以将 id_card 索引换成 （id_card，name）联合索引，因为索引中包含了 name，查询的时候就不需要回表了，这种联合索引也称为覆盖索引。

## 五、联合索引

​		联合索引就是同时以多个列的大小作为排序规则。比如（name，email）索引：

* 先把各个记录和数据页按照 name 字段的大小进行排序
* name 相同的情况下，根据 email 的大小进行排序

![image-20210808192557847](images/image-20210808192557847.png)

## 六、前缀索引



## 七、索引维护及页分裂

​		B+ 树为了维护索引有序性，在插入新值的时候需要做必要的维护。

![image-20210808151500451](images/image-20210808151500451.png)

​		以这个主键索引为例子，假设一个数据页只能存放3条用户数据。如果新纪录的 id 为 50，则只需要在 id 为 45 这条记录后面将新纪录加进去。如果新纪录的 id 为 6，正常情况下只需要将这条记录放到 id 为 5 的这条记录后面即可，但页 28 已经满了，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为页分裂。更糟糕的是，新申请的数据页会多出一条目录项记录，需要将这条目录项记录放入页 30 中，但是页 30 也满了，所以页 30 也会执行页分裂的过程。

​		页分裂除了影响性能外，还会影响数据页的利用率。原本放在一个数据页的数据，现在分到两个数据页中，整体空间利用率大约降低 50%。所以，建表的时候我们一般都会建一个自增索引。

## 

